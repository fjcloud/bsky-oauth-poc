<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bluesky OAuth Client</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            color: #1e88e5;
            margin-bottom: 30px;
        }
        
        .container {
            background-color: #f5f9ff;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .login-form {
            margin-bottom: 20px;
        }
        
        input[type="text"] {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 16px;
        }
        
        button {
            background-color: #1e88e5;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #1565c0;
        }
        
        .result {
            display: none;
            margin-top: 30px;
        }
        
        .token-section {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 20px;
            word-wrap: break-word;
        }
        
        .token-header {
            font-weight: bold;
            margin-bottom: 10px;
            color: #1565c0;
        }
        
        pre {
            background-color: #f8f8f8;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 0;
        }
        
        .error {
            color: #d32f2f;
            background-color: #ffebee;
            padding: 10px;
            border-radius: 4px;
            margin-top: 15px;
        }
        
        .loading {
            margin-top: 20px;
            text-align: center;
            display: none;
        }
        
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top: 4px solid #1e88e5;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .info {
            background-color: #e3f2fd;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Bluesky OAuth Client</h1>
        
        <div class="info">
            This app authenticates with Bluesky using the OAuth 2.0 protocol with DPoP, retrieves your access token, and displays the decoded JWT information.
        </div>
        
        <div id="login-section">
            <div class="login-form">
                <label for="handle-input">Enter your Bluesky handle:</label>
                <input type="text" id="handle-input" placeholder="username.bsky.social">
                <button id="login-btn">Authenticate with Bluesky</button>
            </div>
        </div>
        
        <div id="loading" class="loading">
            <div class="spinner"></div>
            <p>Processing authentication...</p>
        </div>
        
        <div id="error-container" class="error" style="display: none;"></div>
        
        <div id="result-container" class="result">
            <h2>Authentication Successful</h2>
            
            <div class="token-section">
                <div class="token-header">Access Token:</div>
                <pre id="access-token"></pre>
            </div>
            
            <div class="token-section">
                <div class="token-header">Decoded Token Header:</div>
                <pre id="token-header"></pre>
            </div>
            
            <div class="token-section">
                <div class="token-header">Decoded Token Payload:</div>
                <pre id="token-payload"></pre>
            </div>
            
            <button id="logout-btn">Log Out</button>
        </div>
    </div>

    <script>
        // Configuration - Replace with your client information
        const CLIENT_ID = "https://oauth.msl.cloud/oauth/client-metadata.json"; // Your client metadata URL
        const REDIRECT_URI = "https://oauth.msl.cloud/index.html"; // Must match exactly what's in your client-metadata.json
        
        // DOM Elements
        const handleInput = document.getElementById('handle-input');
        const loginBtn = document.getElementById('login-btn');
        const logoutBtn = document.getElementById('logout-btn');
        const loginSection = document.getElementById('login-section');
        const resultContainer = document.getElementById('result-container');
        const loadingElement = document.getElementById('loading');
        const errorContainer = document.getElementById('error-container');
        const accessTokenElement = document.getElementById('access-token');
        const tokenHeaderElement = document.getElementById('token-header');
        const tokenPayloadElement = document.getElementById('token-payload');
        
        // Utility functions
        function showError(message) {
            errorContainer.textContent = `Error: ${message}`;
            errorContainer.style.display = 'block';
            loadingElement.style.display = 'none';
        }
        
        function showLoading() {
            loadingElement.style.display = 'block';
            errorContainer.style.display = 'none';
        }
        
        function hideLoading() {
            loadingElement.style.display = 'none';
        }
        
        // Generate random string for state and PKCE
        function generateRandomString(length) {
            const array = new Uint8Array(length);
            crypto.getRandomValues(array);
            return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
        }
        
        // Base64 URL encode a string or buffer
        function base64UrlEncode(input) {
            let str;
            if (input instanceof ArrayBuffer || input instanceof Uint8Array) {
                str = String.fromCharCode.apply(null, new Uint8Array(input));
            } else {
                str = input;
            }
            return btoa(str)
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=+$/, '');
        }
        
        // Compute SHA-256 hash
        async function sha256(text) {
            const encoder = new TextEncoder();
            const data = encoder.encode(text);
            const hash = await crypto.subtle.digest('SHA-256', data);
            return hash;
        }
        
        // Decode JWT token
        function decodeJWT(token) {
            try {
                const parts = token.split('.');
                if (parts.length !== 3) {
                    throw new Error('Not a valid JWT token');
                }
                
                const header = JSON.parse(atob(parts[0].replace(/-/g, '+').replace(/_/g, '/')));
                const payload = JSON.parse(atob(parts[1].replace(/-/g, '+').replace(/_/g, '/')));
                
                return { header, payload };
            } catch (error) {
                console.error('Error decoding JWT:', error);
                return { header: {}, payload: {} };
            }
        }
        
        // Create and store DPoP proof for a request
        async function createDPoPProof(url, method, nonce = null, accessToken = null) {
            try {
                // Generate a key pair for this request
                const keyPair = await crypto.subtle.generateKey(
                    {
                        name: 'ECDSA',
                        namedCurve: 'P-256'
                    },
                    true, // extractable
                    ['sign', 'verify']
                );
                
                // Export public key to JWK format
                const publicKeyJwk = await crypto.subtle.exportKey('jwk', keyPair.publicKey);
                
                // Create DPoP header
                const header = {
                    typ: 'dpop+jwt',
                    alg: 'ES256',
                    jwk: publicKeyJwk
                };
                
                // Create payload
                const payload = {
                    jti: generateRandomString(32),
                    htm: method,
                    htu: url,
                    iat: Math.floor(Date.now() / 1000)
                };
                
                // Add nonce if provided
                if (nonce) {
                    payload.nonce = nonce;
                }
                
                // Add access token hash if provided
                if (accessToken) {
                    const tokenHash = await sha256(accessToken);
                    payload.ath = base64UrlEncode(tokenHash);
                }
                
                // Encode header and payload
                const encodedHeader = base64UrlEncode(JSON.stringify(header));
                const encodedPayload = base64UrlEncode(JSON.stringify(payload));
                
                // Prepare message to sign
                const message = `${encodedHeader}.${encodedPayload}`;
                const messageBytes = new TextEncoder().encode(message);
                
                // Sign the message
                const signature = await crypto.subtle.sign(
                    {
                        name: 'ECDSA',
                        hash: { name: 'SHA-256' }
                    },
                    keyPair.privateKey,
                    messageBytes
                );
                
                // Encode signature
                const encodedSignature = base64UrlEncode(signature);
                
                // Return the complete JWT
                return `${message}.${encodedSignature}`;
            } catch (error) {
                console.error('Error creating DPoP proof:', error);
                throw error;
            }
        }
        
        // Resolve Bluesky handle to get DID
        async function resolveHandle(handle) {
            try {
                const response = await fetch(`https://bsky.social/xrpc/com.atproto.identity.resolveHandle?handle=${handle}`);
                
                if (!response.ok) {
                    throw new Error(`Failed to resolve handle: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                return data.did;
            } catch (error) {
                console.error('Error resolving handle:', error);
                throw error;
            }
        }
        
        // Get DID document
        async function getDidDocument(did) {
            try {
                const response = await fetch(`https://plc.directory/${did}`);
                
                if (!response.ok) {
                    throw new Error(`Failed to get DID document: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Error getting DID document:', error);
                throw error;
            }
        }
        
        // Get PDS URL from DID document
        function getPdsUrl(didDocument) {
            try {
                const service = didDocument.service.find(s => s.id === '#atproto_pds');
                if (!service) {
                    throw new Error('PDS service not found in DID document');
                }
                return service.serviceEndpoint;
            } catch (error) {
                console.error('Error getting PDS URL:', error);
                throw error;
            }
        }
        
        // Get PDS metadata
        async function getPdsMetadata(pdsUrl) {
            try {
                const response = await fetch(`${pdsUrl}/.well-known/oauth-protected-resource`);
                
                if (!response.ok) {
                    throw new Error(`Failed to get PDS metadata: ${response.status} ${response.statusText}`);
                }
                
                return await response.json();
            } catch (error) {
                console.error('Error getting PDS metadata:', error);
                throw error;
            }
        }
        
        // Get auth server metadata
        async function getAuthServerMetadata(authServerUrl) {
            try {
                const response = await fetch(`${authServerUrl}/.well-known/oauth-authorization-server`);
                
                if (!response.ok) {
                    throw new Error(`Failed to get auth server metadata: ${response.status} ${response.statusText}`);
                }
                
                return await response.json();
            } catch (error) {
                console.error('Error getting auth server metadata:', error);
                throw error;
            }
        }
        
        // Initialize OAuth flow
        async function initOAuthFlow(handle) {
            showLoading();
            try {
                // Store handle
                sessionStorage.setItem('bluesky_handle', handle);
                
                // Generate state and PKCE
                const state = generateRandomString(32);
                // Use localStorage instead of sessionStorage to persist across redirects
                localStorage.setItem('oauth_state', state);
                
                const codeVerifier = generateRandomString(64);
                localStorage.setItem('code_verifier', codeVerifier);
                
                const codeChallenge = base64UrlEncode(await sha256(codeVerifier));
                
                // Resolve handle to get DID
                const did = await resolveHandle(handle);
                sessionStorage.setItem('user_did', did);
                
                // Get DID document
                const didDocument = await getDidDocument(did);
                
                // Get PDS URL from DID document
                const pdsUrl = getPdsUrl(didDocument);
                sessionStorage.setItem('pds_url', pdsUrl);
                
                // Get PDS metadata
                const pdsMetadata = await getPdsMetadata(pdsUrl);
                
                // Get auth server URL from PDS metadata
                const authServerUrl = pdsMetadata.authorization_servers[0];
                sessionStorage.setItem('auth_server_url', authServerUrl);
                
                // Get auth server metadata
                const authServerMetadata = await getAuthServerMetadata(authServerUrl);
                sessionStorage.setItem('auth_server_metadata', JSON.stringify(authServerMetadata));
                
                // Get PAR endpoint
                const parEndpoint = authServerMetadata.pushed_authorization_request_endpoint;
                
                // Make first PAR request to get DPoP nonce
                let parResponse = await fetch(parEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    body: new URLSearchParams({
                        'response_type': 'code',
                        'client_id': CLIENT_ID,
                        'redirect_uri': REDIRECT_URI,
                        'code_challenge_method': 'S256',
                        'code_challenge': codeChallenge,
                        'state': state,
                        'scope': 'atproto',
                        'login_hint': handle
                    })
                });
                
                // Get DPoP nonce from response
                const dpopNonce = parResponse.headers.get('DPoP-Nonce');
                
                if (!dpopNonce) {
                    // If we don't have a nonce, handle error
                    if (!parResponse.ok) {
                        const errorBody = await parResponse.text();
                        throw new Error(`PAR request failed: ${errorBody}`);
                    }
                    throw new Error('No DPoP nonce received from server');
                }
                
                // Store nonce for later use
                sessionStorage.setItem('dpop_nonce', dpopNonce);
                
                // Create DPoP proof for the PAR request
                const dpopProof = await createDPoPProof(parEndpoint, 'POST', dpopNonce);
                
                // Make PAR request with DPoP
                parResponse = await fetch(parEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'DPoP': dpopProof
                    },
                    body: new URLSearchParams({
                        'response_type': 'code',
                        'client_id': CLIENT_ID,
                        'redirect_uri': REDIRECT_URI,
                        'code_challenge_method': 'S256',
                        'code_challenge': codeChallenge,
                        'state': state,
                        'scope': 'atproto',
                        'login_hint': handle
                    })
                });
                
                if (!parResponse.ok) {
                    const errorBody = await parResponse.text();
                    throw new Error(`PAR request failed: ${errorBody}`);
                }
                
                const parData = await parResponse.json();
                const requestUri = parData.request_uri;
                
                // Redirect to auth endpoint
                const authEndpoint = authServerMetadata.authorization_endpoint;
                const authUrl = new URL(authEndpoint);
                authUrl.searchParams.append('client_id', CLIENT_ID);
                authUrl.searchParams.append('request_uri', requestUri);
                
                window.location.href = authUrl.toString();
                
            } catch (error) {
                console.error('Error initializing OAuth flow:', error);
                showError(error.message);
                hideLoading();
            }
        }
        
        // Function to get cookie value
        function getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) return parts.pop().split(';').shift();
            return null;
        }
        
        // Handle OAuth callback
        async function handleCallback() {
            showLoading();
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const code = urlParams.get('code');
                const state = urlParams.get('state');
                const error = urlParams.get('error');
                
                // Try to get stored values from multiple sources
                let storedState = localStorage.getItem('oauth_state');
                let codeVerifier = localStorage.getItem('code_verifier');
                let authServerUrl = localStorage.getItem('auth_server_url');
                let authServerMetadataStr = localStorage.getItem('auth_server_metadata');
                let dpopNonce = localStorage.getItem('dpop_nonce');
                
                console.log("Received in callback - State:", state);
                console.log("Retrieved from localStorage - State:", storedState);
                
                // Try cookies if localStorage failed
                if (!storedState) {
                    storedState = getCookie('oauth_state');
                    codeVerifier = getCookie('code_verifier');
                    authServerUrl = getCookie('auth_server_url');
                    authServerMetadataStr = decodeURIComponent(getCookie('auth_metadata') || '');
                    dpopNonce = getCookie('dpop_nonce');
                    console.log("Retrieved from cookies - State:", storedState);
                }
                
                // Try URL parameters as last resort
                if (!storedState) {
                    storedState = urlParams.get('stored_state');
                    codeVerifier = urlParams.get('stored_verifier');
                    authServerUrl = urlParams.get('stored_auth_url');
                    dpopNonce = urlParams.get('stored_nonce');
                    console.log("Retrieved from URL params - State:", storedState);
                }
                
                if (error) {
                    throw new Error(`Authorization server returned error: ${error}`);
                }
                
                if (!code) {
                    return; // Not a callback
                }
                
                if (!storedState) {
                    console.log("No stored state found, trying to continue without state verification");
                } else if (state !== storedState) {
                    console.warn(`State mismatch: ${state} vs ${storedState}, but continuing anyway`);
                }
                
                if (!codeVerifier) {
                    throw new Error("Could not retrieve code verifier from any storage mechanism");
                }
                
                if (!authServerUrl) {
                    // If we can't get the auth server URL, use Bluesky's default
                    console.log("Using default Bluesky auth server URL");
                    authServerUrl = "https://bsky.social";
                }
                
                // If we don't have auth server metadata, fetch it again
                let authServerMetadata;
                if (!authServerMetadataStr) {
                    console.log("Fetching auth server metadata again");
                    authServerMetadata = await getAuthServerMetadata(authServerUrl);
                } else {
                    try {
                        authServerMetadata = JSON.parse(authServerMetadataStr);
                    } catch (e) {
                        console.log("Error parsing stored auth server metadata, fetching again");
                        authServerMetadata = await getAuthServerMetadata(authServerUrl);
                    }
                }
                
                const tokenEndpoint = authServerMetadata.token_endpoint;
                
                // Fallback to using a new nonce if we don't have one
                if (!dpopNonce) {
                    console.log("No stored nonce found, proceeding without it");
                }
                
                // Create DPoP proof for token request
                const dpopProof = await createDPoPProof(tokenEndpoint, 'POST', dpopNonce);
                
                // Token request with DPoP nonce handling
                let tokenResponse = await fetch(tokenEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'DPoP': dpopProof
                    },
                    body: new URLSearchParams({
                        'grant_type': 'authorization_code',
                        'code': code,
                        'redirect_uri': REDIRECT_URI,
                        'client_id': CLIENT_ID,
                        'code_verifier': codeVerifier
                    })
                });
                
                // Handle DPoP nonce error and retry
                if (tokenResponse.status === 401) {
                    const errorData = await tokenResponse.json();
                    console.log("Token request response:", errorData);
                    
                    if (errorData.error === 'use_dpop_nonce') {
                        // Get the new nonce from the response headers
                        const newNonce = tokenResponse.headers.get('DPoP-Nonce');
                        console.log("Server requires DPoP nonce. Using new nonce:", newNonce);
                        
                        if (newNonce) {
                            // Create a new DPoP proof with the new nonce
                            const newDpopProof = await createDPoPProof(tokenEndpoint, 'POST', newNonce);
                            
                            // Retry the request with the new nonce
                            tokenResponse = await fetch(tokenEndpoint, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/x-www-form-urlencoded',
                                    'DPoP': newDpopProof
                                },
                                body: new URLSearchParams({
                                    'grant_type': 'authorization_code',
                                    'code': code,
                                    'redirect_uri': REDIRECT_URI,
                                    'client_id': CLIENT_ID,
                                    'code_verifier': codeVerifier
                                })
                            });
                        } else {
                            throw new Error("Server requires DPoP nonce but none was provided in the response");
                        }
                    }
                }
                
                if (!tokenResponse.ok) {
                    const errorText = await tokenResponse.text();
                    throw new Error(`Token request failed: ${errorText}`);
                }
                
                const tokenData = await tokenResponse.json();
                localStorage.setItem('access_token', tokenData.access_token);
                localStorage.setItem('refresh_token', tokenData.refresh_token);
                localStorage.setItem('token_type', tokenData.token_type);
                localStorage.setItem('expires_in', tokenData.expires_in);
                
                // Display token data
                displayTokenData(tokenData.access_token);
                
                // Clear URL parameters
                window.history.replaceState({}, document.title, window.location.pathname);
                
            } catch (error) {
                console.error('Error handling callback:', error);
                showError(error.message);
            } finally {
                hideLoading();
            }
        }
        
        // Display token data
        function displayTokenData(accessToken) {
            // Decode token
            const decodedToken = decodeJWT(accessToken);
            
            // Update DOM
            accessTokenElement.textContent = accessToken;
            tokenHeaderElement.textContent = JSON.stringify(decodedToken.header, null, 2);
            tokenPayloadElement.textContent = JSON.stringify(decodedToken.payload, null, 2);
            
            // Show results
            loginSection.style.display = 'none';
            resultContainer.style.display = 'block';
        }
        
        // Check if already logged in
        function checkLoggedIn() {
            const accessToken = localStorage.getItem('access_token');
            if (accessToken) {
                displayTokenData(accessToken);
            }
        }
        
        // Logout function
        function logout() {
            localStorage.clear();
            loginSection.style.display = 'block';
            resultContainer.style.display = 'none';
            errorContainer.style.display = 'none';
        }
        
        // Add event listeners
        loginBtn.addEventListener('click', () => {
            const handle = handleInput.value.trim();
            if (handle) {
                initOAuthFlow(handle);
            } else {
                showError('Please enter your Bluesky handle');
            }
        });
        
        logoutBtn.addEventListener('click', logout);
        
        // Check if this is a callback or logged in
        document.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('code')) {
                handleCallback();
            } else {
                checkLoggedIn();
            }
        });
    </script>
</body>
</html>
